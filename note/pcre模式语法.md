# pcre 模式语法

[参考](http://php.net/manual/zh/reference.pcre.pattern.syntax.php)

## 分隔符

```php
当使用 PCRE 函数的时候，模式需要由分隔符闭合包裹。分隔符可以使任意非字母数字、非反斜线、非空白字符。

经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)。下面的例子都是使用合法分隔符的模式。

/foo bar/
#^[^0-9]$#
+php+
%[a-zA-Z0-9_-]%
如果分隔符需要在模式内进行匹配，它必须使用反斜线进行转义。如果分隔符经常在 模式内出现， 一个更好的选择就是是用其他分隔符来提高可读性。

/http:\/\//
#http://#
需要将一个字符串放入模式中使用时，可以用 preg_quote() 函数对其进行 转义，它的第二个参数(可选)可以用于指定需要被转义的分隔符。
除了上面提到的分隔符，也可以使用括号样式的分隔符，左括号和右括号分别作为开始和结束 分隔符。

{this is a pattern}
可以在结束分隔符后面增加模式修饰符。 下面的例子是一个大小写不敏感的匹配：

#[a-z]#i
```

## 元字符

```php
正则表达式的威力源于它可以在模式中拥有选择和重复的能力。 一些字符被赋予 特殊的涵义，使其不再单纯的代表自己，模式中的这种有特殊涵义的编码字符 称为 元字符。

共有两种不同的元字符：一种是可以在模式中方括号外任何地方使用的，另外一种 是需要在方括号内使用的。 在方括号外使用的元字符如下：

\ 一般用于转义字符
^ 断言目标的开始位置(或在多行模式下是行首)
$ 断言目标的结束位置(或在多行模式下是行尾)
.  匹配除换行符外的任何字符(默认)
[ 开始字符类定义
] 结束字符类定义
| 开始一个可选分支
( 子组的开始标记
) 子组的结束标记
?  作为量词，表示 0 次或 1 次匹配。位于量词后面用于改变量词的贪婪特性。 (查阅量词)
* 量词，0 次或多次匹配
+ 量词，1 次或多次匹配
{ 自定义量词开始标记
} 自定义量词结束标记

模式中方括号内的部分称为“字符类”。 在一个字符类中仅有以下可用元字符：
\ 转义字符
^ 仅在作为第一个字符(方括号内)时，表明字符类取反
- 标记字符范围
```

## 转义序列(反斜线)

```html
反斜线有多种用法。首先，如果紧接着是一个非字母数字字符，表明取消 该字符所代表的特殊涵义。这种将反斜线作为转义字符的用法在字符类 内部和外部都可用。

比如，如果你希望匹配一个 "*" 字符，就需要在模式中写为 "\*"。 这适用于一个字符在不进行转义会有特殊含义的情况下。 但是， 对于非数字字母的字符，总是在需要其进行原文匹配的时候在它前面增加一个反斜线， 来声明它代表自己，这是安全的。如果要匹配一个反斜线，那么在模式中使用 ”\\”。

Note:
反斜线在单引号字符串和双引号字符串 中都有特殊含义，因此要匹配一个反斜线， 模式中必须写为 ”\\\\”。 译注： “/\\/”， 首先它作为字符串，反斜线会进行转义， 那么转义后的结果是/\/，这个才是正则表达式引擎拿到的模式， 而正则表达式引擎也认为 \ 是转义标记，它会将分隔符 / 进行转义， 从而得到的是一个错误，因此，需要 4 个反斜线才可以匹配一个反斜线。
如果一个模式被使用 PCRE_EXTENDED 选项编译， 模式中的空白字符(除了字符类中的)和未转义的#到行末的所有字符都会被忽略。 要在这种情况下使用空白字符或者#，就需要对其进行转义。

反斜线的第二种用途提供了一种对非打印字符进行可见编码的控制手段。 除了二进制的 0 会终结一个模式外，并不会严格的限制非打印字符(自身)的出现， 但是当一个模式以文本编辑器的方式编辑准备的时候， 使用下面的转义序列相比使用二进制字符会更加容易。

\a 响铃字符(十六进制 07)
\cx "control-x"，x 是任意字符
\e 转义 (十六进制 1B)
\f 换页 (十六进制 0C)
\n 换行 (十六进制 0A)
\p{xx} 一个符合 xx 属性的字符，详细查看unicode properties 属性
\P{xx} 一个不符合xx属性的字符，详细查看unicode properties 属性
\r 回车 (十六进制 0D)
\t 水平制表符 (十六进制 09)
\xhh hh十六进制编码的字符，详细查看unicode properties 属性
\ddd ddd八进制编码的字符，或者后向引用

\cx的确切效果如下： 如果x是一个小写字母，它被转换为大写。接着， 将字符的第6位(十六进制 40，右数第一个位为第0位)取反。 比如\cz成为十六进制的1A，\c{成为十六进制3B， \c;成为十六进制7B。

在"\x"后面，读取两个十六进制数(字母可以是大写或小写)。 在UTF-8模式， “\x{…}”允许使用， 花括号内的内容是十六进制有效数字。 它将给出的十六进制数字解释为 UTF-8 字符代码。原来的十六进制转义序列， \xhh， 匹配一个双字节的UTF-8字符，如果它的值大于127

在”\0”之后， 读取两个八进制数。所有情况下，如果数少于2个，则直接使用。 序列 ”\0\x\07” 指定了两个二进制 0 紧跟着一个 BEL 字符。 请确保初始的 0 之后的两个数字是合法的八进制数。

处理一个反斜线紧跟着的不是0的数字的情况比较复杂。在字符类外部， PCRE 读取它并以十进制读取紧随其后的数字。 如果数值小于 10， 或者之前捕获到了该数字能够代表的左括号(子组)， 整个数字序列被认为是后向引用。后向引用如何工作在后面描述， 接下来就会讨论括号子组。

在一个字符类里面，或者十进制数大于 9 并且没有那么多的子组被捕获， PCRE 重新读取反斜线后的第三个 8 进制数字，并且从最低的 8 位生成单字节值。 任何的后续数字都代表它们自身。例如：

\040 空格的另外一种用法
\40 当提供了少于40个子组时也认为是空格。
\7 始终是后向引用
\11 可能是后向引用，也可能是制表符
\011 总是一个制表符
\0113 一个制表符紧跟着一个3(因为每次最多只读取3个8进制位
\113 八进制113代表的字符
\377 8进制377是10进制255， 因此代表一个全1的字符
\81 一个后向引用或者一个二进制 0 紧跟着两个数字 8 和 1(因为8不是8进制有效数字)
注意，八进制值的 100 或者更大的值必须没有前置的0引导， 因为每次最多读取3个8进制位.

所有序列定义的单字节值都可以在字符类内部或外部使用。另外，在字符类中, 序列 ”\b” 解释为退格字符。字符类外它又有不同的意义(下面有描述)

反斜线的第三种用法是用来描述特定的字符类：

\d 任意十进制数字
\D 任意非十进制数字
\h 任意水平空白字符(since PHP 5.2.4)
\H 任意非水平空白字符(since PHP 5.2.4)
\s 任意空白字符
\S 任意非空白字符
\v 任意垂直空白字符(since PHP 5.2.4)
\V 任意非垂直空白字符(since PHP 5.2.4)
\w 任意单词字符
\W 任意非单词字符
上面每一对转义序列都代表了完整字符集中两个不相交的部分， 任意字符一定会匹配其中一个，同时一定不会匹配另外一个。

单词字符指的是任意字母、数字、下划线。 也就是说任意可以组成perl单词的字符。 字母和数字的定义通过PCRE字符表控制，可以通过指定地域设置使其匹配改变。比如， 在法国 (fr) 地域设置中，一些超过 128 的字符代码被用于重音字母， 它们可以实用 \w 匹配。

这些字符类序列在字符类内部或外部都可以出现。 他们每次匹配所代表的字符类型中的一个字符。 如果当前匹配点位于目标字符串末尾， 它们中的所有字符都匹配失败， 因为没有字符让它们匹配了。

反斜线的第四种用法是一些简单的断言。 一个断言指定一个必须在特定位置匹配的条件， 它们不会从目标字符串中消耗任何字符。 接下来我们会讨论使用子组的更加复杂的断言。 反斜线断言包括：

\b 单词边界
\B 非单词边界
\A 目标的开始位置(独立于多行模式)
\Z 目标的结束位置或结束处的换行符(独立于多行模式)
\z 目标的结束位置(独立于多行模式)
\G 在目标中首次匹配位置
这些断言不能出现在字符类中(但是注意， “\b”在字符类中有不同的意义， 表示的是退格(backspace)字符)

一个单词边界表示的是在目标字符串中， 当前字符和前一个字符不同时匹配\w或\W(一个比配\w, 一个匹配\W)， 或者作为字符串开始或结尾字符的时候当前字符匹配\w。

\A， \Z， \z断言不同于传统的^和$(详见下文)， 因为他们永远匹配目标字符串的开始和结尾，而不会受模式修饰符的限制。 它们不受PCRE_MULTILINE，PCRE_DOLLAR_ENDONLY选项的影响。 \Z 和 \z 之间的不同在于当字符串结束字符时换行符时 \Z 会将其看做字符串结尾匹配, 而 \z 只匹配字符串结尾。

\G 断言在指定了$offset 参数的preg_match() 调用中， 仅在当前匹配位置在匹配开始点的时候才是成功的。 当 $offset 的值不为 0 的时候， 它与 \A 是不同的。 译注：另外一点与 \A 的不同之处在于使用 preg_match_all() 时， 每次匹配 \G 只是断言是否是匹配结果的开始位置， 而 \A 断言的则是匹配结果的开始位置是否在目标字符串开始位置。

自 PHP 4.3.3开始， \Q 和 \E 可以用于在模式中忽略正则表达式元字符。比如： \w+\Q.$.\E$ 会匹配一个或多个单词字符，紧接着一个点号，一个$，一个点号， 最后锚向字符串末尾。

自 PHP 5.2.4 开始。 \K 可以用于重置匹配。 比如， foot\Kbar 匹配”footbar”。 但是得到的匹配结果是 ”bar”。但是， \K 的使用不会干预到子组内的内容， 比如 (foot)\Kbar 匹配 ”footbar”，第一个子组内的结果仍然会是 ”foo”。译注： \K 放在子组和子组外面的效果是一样的。
```

## 锚

```
在一个字符类外面，在默认匹配模式下， ^ 是一个断言当前匹配点位于目标字符串开始处的断言。在一个字符类内部， ^ 表明这个字符类中描述的字符取反(详见下文)。

^ 并不一定要是模式的第一个字符， 但是如果处于某个可选分支时， 它应该是该分支的首字符。如果所有选择分支都以 ^ 开头，这就是说， 如果模式限制为只匹配目标的开头， 它被称为是一个 ”紧固” 模式。(同样也有其他方式可以构造出紧固模式)

$ 是用于断言当前匹配点位于目标字符串末尾， 或当目标字符串以换行符结尾时当前匹配点位于该换行符位置(默认情况)。 $ 不一定要作为模式的最后一个字符，但是如果它在某个可选分支中时， 就应该位于该分支的末尾。 $ 在字符类中没有特殊的意义。

$ 的意义可以通过在编译或匹配时设置 PCRE_DOLLAR_ENDONLY 改变为只匹配字符串末尾。 这不会影响 \Z 断言的行为。

^ 和 $ 字符的意义在 PCRE_MULTILINE 选项被设置时会发生变化。 当在这种情况下时， 它们匹配每一个换行符后面的和前面的字符，另外， 也会匹配目标字符串的开始和结束。比如, 模式 /^abc$/ 在多行模式下会成功匹配目标字符串 ”def\nabc”， 而正常情况下不会。因此，由于所有的可选分支都以 ^ 开始， 在单行模式下这成为紧固模式，然而在多行模式下，这是非紧固的。 PCRE_DOLLAR_ENDONLY 选项在PCRE_MULTILINE 设置后失效。

注意： \A、\Z、 \z 等转义序列可以在任何模式下用于匹配目标字符串的开始和结束位置。 并且如果模式的所有分支都以 \A 开始，它同样是紧固的， 而与 PCRE_MULTILINE 是否设置无关。
```

